# 无监督学习

提供的数据没有标签

## 聚类

聚类算法， 在数据中寻找一种特定的结构，将数据集分组成聚类， 即彼此相似的点组。

## K-means

首先随机猜测它要找到的两个聚类的中心在哪里，然后**聚类质心分配点，移动聚类质心**

<img src="./图片/image-20231027235531575.png" alt="image-20231027235531575" style="zoom:33%;" />

<img src="./图片/image-20231027235919423.png" alt="image-20231027235919423" style="zoom:33%;" />

<img src="./图片/image-20231028000215076.png" alt="image-20231028000215076" style="zoom:33%;" />

步骤一：把每个点分配到离它最近的聚类质心

步骤二：将每个聚类质心移动到分配给它的所有点的平均值或平均值

然后重复步骤一、二，直到指向质心的分配或 聚类质心的位置都不会发生进一步的变化，即聚类算法心收敛为止



### K-means算法

<img src="./图片/image-20231028001939746.png" alt="image-20231028001939746" style="zoom:33%;" />

当一个集群没有分配给它的训练示例时，可以消减这个集群，即减去这个聚类或者随机重新初始化聚类质心

<img src="./图片/image-20231028001950176.png" alt="image-20231028001950176" style="zoom:25%;" />

<img src="./图片/image-20231028091717650.png" alt="image-20231028091717650" style="zoom: 25%;" />

J**失真函数**（distortion）的目的：找到聚类质心点的分配，并找到最小化平方距离的聚类质心的位置

<img src="./图片/image-20231028092602631.png" alt="image-20231028092602631" style="zoom: 25%;" />

### 初始化Means

<img src="./图片/image-20231028093435460.png" alt="image-20231028093435460" style="zoom: 25%;" />

<img src="./图片/image-20231028093410780.png" alt="image-20231028093410780" style="zoom:25%;" />

<img src="./图片/image-20231028095635701.png" alt="image-20231028095635701" style="zoom:25%;" />

### 选择聚类的个数

<img src="./图片/image-20231028100132843.png" alt="image-20231028100132843" style="zoom:25%;" />

<img src="./图片/image-20231028100142086.png" alt="image-20231028100142086" style="zoom: 33%;" />

## 异常检测

### 异常检测原理

<img src="./图片/image-20231028100927687.png" alt="image-20231028100927687" style="zoom: 33%;" />

<img src="./图片/image-20231028100851852.png" alt="image-20231028100851852" style="zoom: 33%;" />

不同的区域有不同的可能性值，值越小的越可能是异常

异常检测的应用：

<img src="./图片/image-20231028100828078.png" alt="image-20231028100828078" style="zoom: 33%;" />

### 高斯（正态）分布

Gauss（Normal/bell-shaped）distribution 高斯（正态/钟形）分布

<img src="./图片/image-20231028101835978.png" alt="image-20231028101835978" style="zoom:33%;" />

<img src="./图片/image-20231028101949238.png" alt="image-20231028101949238" style="zoom: 33%;" />

<img src="./图片/image-20231028102213310.png" alt="image-20231028102213310" style="zoom:33%;" />

### 异常检测算法

<img src="./图片/image-20231028103955803.png" alt="image-20231028103955803" style="zoom:33%;" />

<img src="./图片/image-20231028104257447.png" alt="image-20231028104257447" style="zoom:33%;" />

如果一个或多个特征相对于训练集中的内容来说非常大或非常小，它往往会将一个例子标记为异常

如果新示例的其中一个功能远远超出了这里，那么 P会非常小。如果这个乘积中只有一个项非常小，那么当你乘在一起时，这个总体乘积往往会很小，p (x) 会很小。 

异常检测对算法的作用 是一种系统的量化方法，可以量化这个新示例 x 是否具有异常大或异常小的特征。

<img src="./图片/image-20231028104703434.png" alt="image-20231028104703434" style="zoom:33%;" />



开发和评估异常检测系统

<img src="./图片/image-20231028104950911.png" alt="image-20231028104950911" style="zoom: 33%;" />

<img src="./图片/image-20231028105317871.png" alt="image-20231028105317871" style="zoom:33%;" />

将异常数据分为两部分，交叉验证集和测试集都包含正常数据和异常数据

系统先在训练集上训练，然后在交叉验证集（CV）上运行，运行后调整算法的参数，比如判断是否异常的临界值ɛ

最后再在测试集上运行

当异常数据过少的时候，可以没有测试集，所有的异常数据都在交叉验证集里

<img src="./图片/image-20231028105938003.png" alt="image-20231028105938003" style="zoom:33%;" />

### 异常检测 VS. 监督学习

<img src="./图片/image-20231028110258434.png" alt="image-20231028110258434" style="zoom:33%;" />

异常检测试图找到全新的正面例子，这些例子可能与 你以前见过的任何事情都不一样。 

其中，监督学习着眼于你的正面例子，并 试图决定未来的例子是否与 你已经看到的正面例子相似

<img src="./图片/image-20231028110729070.png" alt="image-20231028110729070" style="zoom:33%;" />

### 特征选择

<img src="./图片/image-20231028111139345.png" alt="image-20231028111139345" style="zoom:33%;" />

对于分布不像高斯分布的特征，可以先进行转换

<img src="./图片/image-20231028111717216.png" alt="image-20231028111717216" style="zoom:33%;" />

<img src="./图片/image-20231028111911372.png" alt="image-20231028111911372" style="zoom:33%;" />



## 推荐系统 

### 协同过滤

<img src="./图片/image-20231028114932041.png" alt="image-20231028114932041" style="zoom:33%;" />

<img src="./图片/image-20231028115247528.png" alt="image-20231028115247528" style="zoom:33%;" />

<img src="./图片/image-20231028115627125.png" alt="image-20231028115627125" style="zoom:33%;" />

<img src="./图片/image-20231028125503911.png" alt="image-20231028125503911" style="zoom:33%;" />

与线性回归不同之处在于，这这个损失函数为n中的每一个训练一个不同的线性回归模型



#### 协同过滤算法（collaborative filtering)

<img src="./图片/image-20231028130745455.png" alt="image-20231028130745455" style="zoom:33%;" />

<img src="./图片/image-20231028130640032.png" alt="image-20231028130640032" style="zoom:33%;" />

<img src="./图片/image-20231028132504655.png" alt="image-20231028132504655" style="zoom:33%;" />

<img src="./图片/image-20231028132752133.png" alt="image-20231028132752133" style="zoom:33%;" />

w,b,x都是参数



 协同过滤的目的：

由于多个用户同一部电影进行了协作评分，因此你可以了解这部电影可能是什么样子， 这可以让你猜出该电影有哪些合适的特征， 这反过来又可以让你 预测其他尚未对同一部电影进行评分的用户将来会如何决定对其进行评分。 

#### 二进制标签

<img src="./图片/image-20231028134916631.png" alt="image-20231028134916631" style="zoom:33%;" />

<img src="./图片/image-20231028134954353.png" alt="image-20231028134954353" style="zoom:33%;" />

<img src="./图片/image-20231028135021302.png" alt="image-20231028135021302" style="zoom:33%;" />

#### 均值归一化

归一化前：

<img src="./图片/image-20231028142342391.png" alt="image-20231028142342391" style="zoom:33%;" />

算法会预测所有电影都没有过评分记录的用户给电影的评分都是0

 归一化后：

<img src="./图片/image-20231028142504584.png" alt="image-20231028142504584" style="zoom:33%;" />

对行使用均值归一化，算法会预测所有电影都没有过评分记录的用户给电影的评分都是0，还原回去后就是每部电影的评分的平均值，不再是0

在这个情境中，对列归一化没有意义



#### 协同过滤的Tensorflow实现

<img src="./图片/image-20231028143708816.png" alt="image-20231028143708816" style="zoom:33%;" />

<img src="./图片/image-20231028143913842.png" alt="image-20231028143913842" style="zoom:33%;" />

#### 查找相关项目

<img src="./图片/image-20231028144347140.png" alt="image-20231028144347140" style="zoom:33%;" />

协同过滤的缺陷：

<img src="./图片/image-20231028144615204.png" alt="image-20231028144615204" style="zoom:33%;" />

冷启动问题。：

例如，如果你的目录中有一个新项目，比如说有人刚刚发布了一部新电影， 但几乎没有人给这部电影打过分，该如何对新项目进行排名？ 同样，对于只给几个项目评分的新用户， 我们怎样才能确保向他们展示一些合理的东西？ 我们可以在之前的视频中看到，均值归一化可以如何帮助解决 这个问题，而且确实有很大帮助。 但是，也许还有更好的方法来向 用户展示那些评分很少的项目，以及他们可能感兴趣的东西。 这被称为冷启动问题， 因为当你有新项目时，评分的用户很少， 或者我们的新用户评分的项目很少，那么对该项目或该用户的协作筛选结果可能不太准确。





### 基于内容的过滤

#### 基于内容的过滤

<img src="./图片/image-20231028153424915.png" alt="image-20231028153424915" style="zoom:33%;" />

<img src="./图片/image-20231028153815907.png" alt="image-20231028153815907" style="zoom:33%;" />

<img src="./图片/image-20231028154119033.png" alt="image-20231028154119033" style="zoom:33%;" />

在协作过滤中， 许多用户对不同的项目进行评分。 

在基于内容的过滤中，根据用户的特征和项目的特征，来进行用户和项目之间的良好匹配，方法是计算这些向量， v_u 代表用户，v_m 代表电影中的项目， 然后在它们之间取点积来尝试找到合适的匹配项

Xv,Xm 的大小可能不同，但向量Vu,Vm的大小必须相同，因为它们之间要做点积

<img src="./图片/image-20231028155151908.png" alt="image-20231028155151908" style="zoom:33%;" />

<img src="./图片/image-20231028155407217.png" alt="image-20231028155407217" style="zoom:33%;" />

<img src="./图片/image-20231028155545736.png" alt="image-20231028155545736" style="zoom:33%;" />



#### 从大目录中推荐

<img src="./图片/image-20231028160054049.png" alt="image-20231028160054049" style="zoom:33%;" />

<img src="./图片/image-20231028160112386.png" alt="image-20231028160112386" style="zoom:33%;" />

<img src="./图片/image-20231028160244443.png" alt="image-20231028160244443" style="zoom:33%;" />

<img src="./图片/image-20231028160509297.png" alt="image-20231028160509297" style="zoom:33%;" />

#### 基于内容过滤的Tensorflow实现

<img src="./图片/image-20231028161620791.png" alt="image-20231028161620791" style="zoom: 50%;" />
